// Code generated by trunnel. DO NOT EDIT.

package arrays

import (
	"encoding/binary"
	"errors"
)

type SimpleArray struct {
	Count uint8
	Data  []uint8
}

func (s *SimpleArray) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Count = cur[0]
		cur = cur[1:]
	}
	{
		s.Data = make([]uint8, int(s.Count))
		for idx := 0; idx < int(s.Count); idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			s.Data[idx] = cur[0]
			cur = cur[1:]
		}
	}
	return cur, nil
}

func ParseSimpleArray(data []byte) (*SimpleArray, error) {
	s := new(SimpleArray)
	_, err := s.Parse(data)
	if err != nil {
		return nil, err
	}
	return s, nil
}

func (s *SimpleArray) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(s.Count))
	for idx := 0; idx < int(s.Count); idx++ {
		buf = append(buf, byte(s.Data[idx]))
	}
	return buf
}

func (s *SimpleArray) MarshalBinary() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	return s.encodeBinary(), nil
}

func (s *SimpleArray) validate() error {
	if len(s.Data) != int(s.Count) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(s.Data); idx++ {
	}
	return nil
}

type FixedArray struct {
	Values  [4]uint8
	Numbers [3]uint16
}

func (f *FixedArray) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		for idx := 0; idx < 4; idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			f.Values[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		for idx := 0; idx < 3; idx++ {
			if len(cur) < 2 {
				return nil, errors.New("data too short")
			}
			f.Numbers[idx] = binary.BigEndian.Uint16(cur)
			cur = cur[2:]
		}
	}
	return cur, nil
}

func ParseFixedArray(data []byte) (*FixedArray, error) {
	f := new(FixedArray)
	_, err := f.Parse(data)
	if err != nil {
		return nil, err
	}
	return f, nil
}

func (f *FixedArray) encodeBinary() []byte {
	var buf []byte
	for idx := 0; idx < 4; idx++ {
		buf = append(buf, byte(f.Values[idx]))
	}
	for idx := 0; idx < 3; idx++ {
		{
			tmp := make([]byte, 2)
			binary.BigEndian.PutUint16(tmp, f.Numbers[idx])
			buf = append(buf, tmp...)
		}
	}
	return buf
}

func (f *FixedArray) MarshalBinary() ([]byte, error) {
	if err := f.validate(); err != nil {
		return nil, err
	}
	return f.encodeBinary(), nil
}

func (f *FixedArray) validate() error {
	if len(f.Values) != 4 {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(f.Values); idx++ {
	}
	if len(f.Numbers) != 3 {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(f.Numbers); idx++ {
	}
	return nil
}
