// Code generated by trunnel. DO NOT EDIT.

package socks5

import (
	"bytes"
	"encoding/binary"
	"errors"
)

type Socks5ClientVersion struct {
	Version  uint8
	NMethods uint8
	Methods  []uint8
}

func (s *Socks5ClientVersion) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Version = cur[0]
		if !(s.Version == 5) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.NMethods = cur[0]
		cur = cur[1:]
	}
	{
		s.Methods = make([]uint8, int(s.NMethods))
		for idx := 0; idx < int(s.NMethods); idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			s.Methods[idx] = cur[0]
			cur = cur[1:]
		}
	}
	return cur, nil
}

func ParseSocks5ClientVersion(data []byte) (*Socks5ClientVersion, error) {
	s := new(Socks5ClientVersion)
	_, err := s.Parse(data)
	if err != nil {
		return nil, err
	}
	return s, nil
}

func (s *Socks5ClientVersion) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(s.Version))
	buf = append(buf, byte(s.NMethods))
	for idx := 0; idx < int(s.NMethods); idx++ {
		buf = append(buf, byte(s.Methods[idx]))
	}
	return buf
}

func (s *Socks5ClientVersion) MarshalBinary() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	return s.encodeBinary(), nil
}

func (s *Socks5ClientVersion) validate() error {
	if !(s.Version == 5) {
		return errors.New("integer constraint violated")
	}
	if len(s.Methods) != int(s.NMethods) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(s.Methods); idx++ {
	}
	return nil
}

type Socks5ServerMethod struct {
	Version uint8
	Method  uint8
}

func (s *Socks5ServerMethod) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Version = cur[0]
		if !(s.Version == 5) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Method = cur[0]
		cur = cur[1:]
	}
	return cur, nil
}

func ParseSocks5ServerMethod(data []byte) (*Socks5ServerMethod, error) {
	s := new(Socks5ServerMethod)
	_, err := s.Parse(data)
	if err != nil {
		return nil, err
	}
	return s, nil
}

func (s *Socks5ServerMethod) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(s.Version))
	buf = append(buf, byte(s.Method))
	return buf
}

func (s *Socks5ServerMethod) MarshalBinary() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	return s.encodeBinary(), nil
}

func (s *Socks5ServerMethod) validate() error {
	if !(s.Version == 5) {
		return errors.New("integer constraint violated")
	}
	return nil
}

type Domainname struct {
	Len  uint8
	Name []byte
}

func (d *Domainname) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		d.Len = cur[0]
		cur = cur[1:]
	}
	{
		d.Name = make([]byte, int(d.Len))
		for idx := 0; idx < int(d.Len); idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			d.Name[idx] = cur[0]
			cur = cur[1:]
		}
	}
	return cur, nil
}

func ParseDomainname(data []byte) (*Domainname, error) {
	d := new(Domainname)
	_, err := d.Parse(data)
	if err != nil {
		return nil, err
	}
	return d, nil
}

func (d *Domainname) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(d.Len))
	for idx := 0; idx < int(d.Len); idx++ {
		buf = append(buf, byte(d.Name[idx]))
	}
	return buf
}

func (d *Domainname) MarshalBinary() ([]byte, error) {
	if err := d.validate(); err != nil {
		return nil, err
	}
	return d.encodeBinary(), nil
}

func (d *Domainname) validate() error {
	if len(d.Name) != int(d.Len) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(d.Name); idx++ {
	}
	return nil
}

type Socks5ClientRequest struct {
	Version    uint8
	Command    uint8
	Reserved   uint8
	Atype      uint8
	Ipv4       uint32
	Ipv6       [16]uint8
	Domainname *Domainname
	DestPort   uint16
}

func (s *Socks5ClientRequest) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Version = cur[0]
		if !(s.Version == 5) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Command = cur[0]
		if !(s.Command == 1 || s.Command == 2 || s.Command == 3 || s.Command == 241) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Reserved = cur[0]
		if !(s.Reserved == 0) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Atype = cur[0]
		cur = cur[1:]
	}
	{
		switch {
		case s.Atype == 1:
			{
				if len(cur) < 4 {
					return nil, errors.New("data too short")
				}
				s.Ipv4 = binary.BigEndian.Uint32(cur)
				cur = cur[4:]
			}
		case s.Atype == 4:
			{
				for idx := 0; idx < 16; idx++ {
					if len(cur) < 1 {
						return nil, errors.New("data too short")
					}
					s.Ipv6[idx] = cur[0]
					cur = cur[1:]
				}
			}
		case s.Atype == 3:
			{
				var err error
				s.Domainname = new(Domainname)
				cur, err = s.Domainname.Parse(cur)
				if err != nil {
					return nil, err
				}
			}
		default:
			{
				return nil, errors.New("disallowed case")
			}
		}
	}
	{
		if len(cur) < 2 {
			return nil, errors.New("data too short")
		}
		s.DestPort = binary.BigEndian.Uint16(cur)
		cur = cur[2:]
	}
	return cur, nil
}

func ParseSocks5ClientRequest(data []byte) (*Socks5ClientRequest, error) {
	s := new(Socks5ClientRequest)
	_, err := s.Parse(data)
	if err != nil {
		return nil, err
	}
	return s, nil
}

func (s *Socks5ClientRequest) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(s.Version))
	buf = append(buf, byte(s.Command))
	buf = append(buf, byte(s.Reserved))
	buf = append(buf, byte(s.Atype))
	switch {
	case s.Atype == 1:
		{
			tmp := make([]byte, 4)
			binary.BigEndian.PutUint32(tmp, s.Ipv4)
			buf = append(buf, tmp...)
		}
	case s.Atype == 4:
		for idx := 0; idx < 16; idx++ {
			buf = append(buf, byte(s.Ipv6[idx]))
		}
	case s.Atype == 3:
		buf = append(buf, s.Domainname.encodeBinary()...)
	default:
	}
	{
		tmp := make([]byte, 2)
		binary.BigEndian.PutUint16(tmp, s.DestPort)
		buf = append(buf, tmp...)
	}
	return buf
}

func (s *Socks5ClientRequest) MarshalBinary() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	return s.encodeBinary(), nil
}

func (s *Socks5ClientRequest) validate() error {
	if !(s.Version == 5) {
		return errors.New("integer constraint violated")
	}
	if !(s.Command == 1 || s.Command == 2 || s.Command == 3 || s.Command == 241) {
		return errors.New("integer constraint violated")
	}
	if !(s.Reserved == 0) {
		return errors.New("integer constraint violated")
	}
	switch {
	case s.Atype == 1:
	case s.Atype == 4:
		if len(s.Ipv6) != 16 {
			return errors.New("array length constraint violated")
		}
		for idx := 0; idx < len(s.Ipv6); idx++ {
		}
	case s.Atype == 3:
		if s.Domainname != nil {
			if err := s.Domainname.validate(); err != nil {
				return err
			}
		}
	default:
	}
	return nil
}

type Socks5ServerReply struct {
	Version    uint8
	Reply      uint8
	Reserved   uint8
	Atype      uint8
	Ipv4       uint32
	Ipv6       [16]uint8
	Domainname *Domainname
	BindPort   uint16
}

func (s *Socks5ServerReply) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Version = cur[0]
		if !(s.Version == 5) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Reply = cur[0]
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Reserved = cur[0]
		if !(s.Reserved == 0) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Atype = cur[0]
		cur = cur[1:]
	}
	{
		switch {
		case s.Atype == 1:
			{
				if len(cur) < 4 {
					return nil, errors.New("data too short")
				}
				s.Ipv4 = binary.BigEndian.Uint32(cur)
				cur = cur[4:]
			}
		case s.Atype == 4:
			{
				for idx := 0; idx < 16; idx++ {
					if len(cur) < 1 {
						return nil, errors.New("data too short")
					}
					s.Ipv6[idx] = cur[0]
					cur = cur[1:]
				}
			}
		case s.Atype == 3:
			{
				var err error
				s.Domainname = new(Domainname)
				cur, err = s.Domainname.Parse(cur)
				if err != nil {
					return nil, err
				}
			}
		default:
			{
				return nil, errors.New("disallowed case")
			}
		}
	}
	{
		if len(cur) < 2 {
			return nil, errors.New("data too short")
		}
		s.BindPort = binary.BigEndian.Uint16(cur)
		cur = cur[2:]
	}
	return cur, nil
}

func ParseSocks5ServerReply(data []byte) (*Socks5ServerReply, error) {
	s := new(Socks5ServerReply)
	_, err := s.Parse(data)
	if err != nil {
		return nil, err
	}
	return s, nil
}

func (s *Socks5ServerReply) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(s.Version))
	buf = append(buf, byte(s.Reply))
	buf = append(buf, byte(s.Reserved))
	buf = append(buf, byte(s.Atype))
	switch {
	case s.Atype == 1:
		{
			tmp := make([]byte, 4)
			binary.BigEndian.PutUint32(tmp, s.Ipv4)
			buf = append(buf, tmp...)
		}
	case s.Atype == 4:
		for idx := 0; idx < 16; idx++ {
			buf = append(buf, byte(s.Ipv6[idx]))
		}
	case s.Atype == 3:
		buf = append(buf, s.Domainname.encodeBinary()...)
	default:
	}
	{
		tmp := make([]byte, 2)
		binary.BigEndian.PutUint16(tmp, s.BindPort)
		buf = append(buf, tmp...)
	}
	return buf
}

func (s *Socks5ServerReply) MarshalBinary() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	return s.encodeBinary(), nil
}

func (s *Socks5ServerReply) validate() error {
	if !(s.Version == 5) {
		return errors.New("integer constraint violated")
	}
	if !(s.Reserved == 0) {
		return errors.New("integer constraint violated")
	}
	switch {
	case s.Atype == 1:
	case s.Atype == 4:
		if len(s.Ipv6) != 16 {
			return errors.New("array length constraint violated")
		}
		for idx := 0; idx < len(s.Ipv6); idx++ {
		}
	case s.Atype == 3:
		if s.Domainname != nil {
			if err := s.Domainname.validate(); err != nil {
				return err
			}
		}
	default:
	}
	return nil
}

type Socks5ClientUserpassAuth struct {
	Version     uint8
	UsernameLen uint8
	Username    []byte
	PasswdLen   uint8
	Passwd      []byte
}

func (s *Socks5ClientUserpassAuth) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Version = cur[0]
		if !(s.Version == 1) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.UsernameLen = cur[0]
		cur = cur[1:]
	}
	{
		s.Username = make([]byte, int(s.UsernameLen))
		for idx := 0; idx < int(s.UsernameLen); idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			s.Username[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.PasswdLen = cur[0]
		cur = cur[1:]
	}
	{
		s.Passwd = make([]byte, int(s.PasswdLen))
		for idx := 0; idx < int(s.PasswdLen); idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			s.Passwd[idx] = cur[0]
			cur = cur[1:]
		}
	}
	return cur, nil
}

func ParseSocks5ClientUserpassAuth(data []byte) (*Socks5ClientUserpassAuth, error) {
	s := new(Socks5ClientUserpassAuth)
	_, err := s.Parse(data)
	if err != nil {
		return nil, err
	}
	return s, nil
}

func (s *Socks5ClientUserpassAuth) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(s.Version))
	buf = append(buf, byte(s.UsernameLen))
	for idx := 0; idx < int(s.UsernameLen); idx++ {
		buf = append(buf, byte(s.Username[idx]))
	}
	buf = append(buf, byte(s.PasswdLen))
	for idx := 0; idx < int(s.PasswdLen); idx++ {
		buf = append(buf, byte(s.Passwd[idx]))
	}
	return buf
}

func (s *Socks5ClientUserpassAuth) MarshalBinary() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	return s.encodeBinary(), nil
}

func (s *Socks5ClientUserpassAuth) validate() error {
	if !(s.Version == 1) {
		return errors.New("integer constraint violated")
	}
	if len(s.Username) != int(s.UsernameLen) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(s.Username); idx++ {
	}
	if len(s.Passwd) != int(s.PasswdLen) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(s.Passwd); idx++ {
	}
	return nil
}

type Socks5ServerUserpathAuth struct {
	Version uint8
	Status  uint8
}

func (s *Socks5ServerUserpathAuth) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Version = cur[0]
		if !(s.Version == 1) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Status = cur[0]
		cur = cur[1:]
	}
	return cur, nil
}

func ParseSocks5ServerUserpathAuth(data []byte) (*Socks5ServerUserpathAuth, error) {
	s := new(Socks5ServerUserpathAuth)
	_, err := s.Parse(data)
	if err != nil {
		return nil, err
	}
	return s, nil
}

func (s *Socks5ServerUserpathAuth) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(s.Version))
	buf = append(buf, byte(s.Status))
	return buf
}

func (s *Socks5ServerUserpathAuth) MarshalBinary() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	return s.encodeBinary(), nil
}

func (s *Socks5ServerUserpathAuth) validate() error {
	if !(s.Version == 1) {
		return errors.New("integer constraint violated")
	}
	return nil
}

type Socks4ClientRequest struct {
	Version  uint8
	Command  uint8
	Port     uint16
	Addr     uint32
	Username string
	Hostname string
}

func (s *Socks4ClientRequest) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Version = cur[0]
		if !(s.Version == 4) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Command = cur[0]
		if !(s.Command == 1 || s.Command == 2 || s.Command == 241) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		if len(cur) < 2 {
			return nil, errors.New("data too short")
		}
		s.Port = binary.BigEndian.Uint16(cur)
		cur = cur[2:]
	}
	{
		if len(cur) < 4 {
			return nil, errors.New("data too short")
		}
		s.Addr = binary.BigEndian.Uint32(cur)
		cur = cur[4:]
	}
	{
		i := bytes.IndexByte(cur, 0)
		if i < 0 {
			return nil, errors.New("could not parse nul-term string")
		}
		s.Username, cur = string(cur[:i]), cur[i+1:]
	}
	{
		switch {
		case (1 <= s.Addr && s.Addr <= 255):
			{
				i := bytes.IndexByte(cur, 0)
				if i < 0 {
					return nil, errors.New("could not parse nul-term string")
				}
				s.Hostname, cur = string(cur[:i]), cur[i+1:]
			}
		default:
		}
	}
	return cur, nil
}

func ParseSocks4ClientRequest(data []byte) (*Socks4ClientRequest, error) {
	s := new(Socks4ClientRequest)
	_, err := s.Parse(data)
	if err != nil {
		return nil, err
	}
	return s, nil
}

func (s *Socks4ClientRequest) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(s.Version))
	buf = append(buf, byte(s.Command))
	{
		tmp := make([]byte, 2)
		binary.BigEndian.PutUint16(tmp, s.Port)
		buf = append(buf, tmp...)
	}
	{
		tmp := make([]byte, 4)
		binary.BigEndian.PutUint32(tmp, s.Addr)
		buf = append(buf, tmp...)
	}
	buf = append(buf, []byte(s.Username)...)
	buf = append(buf, 0)
	switch {
	case (1 <= s.Addr && s.Addr <= 255):
		buf = append(buf, []byte(s.Hostname)...)
		buf = append(buf, 0)
	default:
	}
	return buf
}

func (s *Socks4ClientRequest) MarshalBinary() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	return s.encodeBinary(), nil
}

func (s *Socks4ClientRequest) validate() error {
	if !(s.Version == 4) {
		return errors.New("integer constraint violated")
	}
	if !(s.Command == 1 || s.Command == 2 || s.Command == 241) {
		return errors.New("integer constraint violated")
	}
	switch {
	case (1 <= s.Addr && s.Addr <= 255):
	default:
	}
	return nil
}

type Socks4ServerReply struct {
	Version uint8
	Status  uint8
	Port    uint16
	Addr    uint32
}

func (s *Socks4ServerReply) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Version = cur[0]
		if !(s.Version == 4) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		s.Status = cur[0]
		cur = cur[1:]
	}
	{
		if len(cur) < 2 {
			return nil, errors.New("data too short")
		}
		s.Port = binary.BigEndian.Uint16(cur)
		cur = cur[2:]
	}
	{
		if len(cur) < 4 {
			return nil, errors.New("data too short")
		}
		s.Addr = binary.BigEndian.Uint32(cur)
		cur = cur[4:]
	}
	return cur, nil
}

func ParseSocks4ServerReply(data []byte) (*Socks4ServerReply, error) {
	s := new(Socks4ServerReply)
	_, err := s.Parse(data)
	if err != nil {
		return nil, err
	}
	return s, nil
}

func (s *Socks4ServerReply) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(s.Version))
	buf = append(buf, byte(s.Status))
	{
		tmp := make([]byte, 2)
		binary.BigEndian.PutUint16(tmp, s.Port)
		buf = append(buf, tmp...)
	}
	{
		tmp := make([]byte, 4)
		binary.BigEndian.PutUint32(tmp, s.Addr)
		buf = append(buf, tmp...)
	}
	return buf
}

func (s *Socks4ServerReply) MarshalBinary() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	return s.encodeBinary(), nil
}

func (s *Socks4ServerReply) validate() error {
	if !(s.Version == 4) {
		return errors.New("integer constraint violated")
	}
	return nil
}

type TorSocksauthKeyval struct {
	Keylen uint16
	Key    []byte
	Vallen uint16
	Val    []byte
}

func (t *TorSocksauthKeyval) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 2 {
			return nil, errors.New("data too short")
		}
		t.Keylen = binary.BigEndian.Uint16(cur)
		cur = cur[2:]
	}
	{
		t.Key = make([]byte, int(t.Keylen))
		for idx := 0; idx < int(t.Keylen); idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			t.Key[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		if len(cur) < 2 {
			return nil, errors.New("data too short")
		}
		t.Vallen = binary.BigEndian.Uint16(cur)
		cur = cur[2:]
	}
	{
		t.Val = make([]byte, int(t.Vallen))
		for idx := 0; idx < int(t.Vallen); idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			t.Val[idx] = cur[0]
			cur = cur[1:]
		}
	}
	return cur, nil
}

func ParseTorSocksauthKeyval(data []byte) (*TorSocksauthKeyval, error) {
	t := new(TorSocksauthKeyval)
	_, err := t.Parse(data)
	if err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TorSocksauthKeyval) encodeBinary() []byte {
	var buf []byte
	{
		tmp := make([]byte, 2)
		binary.BigEndian.PutUint16(tmp, t.Keylen)
		buf = append(buf, tmp...)
	}
	for idx := 0; idx < int(t.Keylen); idx++ {
		buf = append(buf, byte(t.Key[idx]))
	}
	{
		tmp := make([]byte, 2)
		binary.BigEndian.PutUint16(tmp, t.Vallen)
		buf = append(buf, tmp...)
	}
	for idx := 0; idx < int(t.Vallen); idx++ {
		buf = append(buf, byte(t.Val[idx]))
	}
	return buf
}

func (t *TorSocksauthKeyval) MarshalBinary() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	return t.encodeBinary(), nil
}

func (t *TorSocksauthKeyval) validate() error {
	if len(t.Key) != int(t.Keylen) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(t.Key); idx++ {
	}
	if len(t.Val) != int(t.Vallen) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(t.Val); idx++ {
	}
	return nil
}

type TorExtendedSocksAuthRequest struct {
	Version uint8
	Npairs  uint16
	Pairs   []*TorSocksauthKeyval
}

func (t *TorExtendedSocksAuthRequest) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		t.Version = cur[0]
		if !(t.Version == 1) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		if len(cur) < 2 {
			return nil, errors.New("data too short")
		}
		t.Npairs = binary.BigEndian.Uint16(cur)
		cur = cur[2:]
	}
	{
		t.Pairs = make([]*TorSocksauthKeyval, int(t.Npairs))
		for idx := 0; idx < int(t.Npairs); idx++ {
			var err error
			t.Pairs[idx] = new(TorSocksauthKeyval)
			cur, err = t.Pairs[idx].Parse(cur)
			if err != nil {
				return nil, err
			}
		}
	}
	return cur, nil
}

func ParseTorExtendedSocksAuthRequest(data []byte) (*TorExtendedSocksAuthRequest, error) {
	t := new(TorExtendedSocksAuthRequest)
	_, err := t.Parse(data)
	if err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TorExtendedSocksAuthRequest) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(t.Version))
	{
		tmp := make([]byte, 2)
		binary.BigEndian.PutUint16(tmp, t.Npairs)
		buf = append(buf, tmp...)
	}
	for idx := 0; idx < int(t.Npairs); idx++ {
		buf = append(buf, t.Pairs[idx].encodeBinary()...)
	}
	return buf
}

func (t *TorExtendedSocksAuthRequest) MarshalBinary() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	return t.encodeBinary(), nil
}

func (t *TorExtendedSocksAuthRequest) validate() error {
	if !(t.Version == 1) {
		return errors.New("integer constraint violated")
	}
	if len(t.Pairs) != int(t.Npairs) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(t.Pairs); idx++ {
		if t.Pairs[idx] != nil {
			if err := t.Pairs[idx].validate(); err != nil {
				return err
			}
		}
	}
	return nil
}

type TorExtendedSocksAuthResponse struct {
	Version uint8
	Status  uint8
	Npairs  uint16
	Pairs   []*TorSocksauthKeyval
}

func (t *TorExtendedSocksAuthResponse) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		t.Version = cur[0]
		if !(t.Version == 1) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		t.Status = cur[0]
		cur = cur[1:]
	}
	{
		if len(cur) < 2 {
			return nil, errors.New("data too short")
		}
		t.Npairs = binary.BigEndian.Uint16(cur)
		cur = cur[2:]
	}
	{
		t.Pairs = make([]*TorSocksauthKeyval, int(t.Npairs))
		for idx := 0; idx < int(t.Npairs); idx++ {
			var err error
			t.Pairs[idx] = new(TorSocksauthKeyval)
			cur, err = t.Pairs[idx].Parse(cur)
			if err != nil {
				return nil, err
			}
		}
	}
	return cur, nil
}

func ParseTorExtendedSocksAuthResponse(data []byte) (*TorExtendedSocksAuthResponse, error) {
	t := new(TorExtendedSocksAuthResponse)
	_, err := t.Parse(data)
	if err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TorExtendedSocksAuthResponse) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(t.Version))
	buf = append(buf, byte(t.Status))
	{
		tmp := make([]byte, 2)
		binary.BigEndian.PutUint16(tmp, t.Npairs)
		buf = append(buf, tmp...)
	}
	for idx := 0; idx < int(t.Npairs); idx++ {
		buf = append(buf, t.Pairs[idx].encodeBinary()...)
	}
	return buf
}

func (t *TorExtendedSocksAuthResponse) MarshalBinary() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	return t.encodeBinary(), nil
}

func (t *TorExtendedSocksAuthResponse) validate() error {
	if !(t.Version == 1) {
		return errors.New("integer constraint violated")
	}
	if len(t.Pairs) != int(t.Npairs) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(t.Pairs); idx++ {
		if t.Pairs[idx] != nil {
			if err := t.Pairs[idx].validate(); err != nil {
				return err
			}
		}
	}
	return nil
}
