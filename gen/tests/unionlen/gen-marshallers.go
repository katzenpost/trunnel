// Code generated by trunnel. DO NOT EDIT.

package unionlen

import (
	"encoding/binary"
	"errors"
)

type UnionWithLen struct {
	Tag                uint16
	UnionLen           uint16
	R                  uint8
	G                  uint8
	B                  uint8
	Year               uint16
	Month              uint8
	Day                uint8
	Unparseable        []uint8
	RightAfterTheUnion uint16
}

func (u *UnionWithLen) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 2 {
			return nil, errors.New("data too short")
		}
		u.Tag = binary.BigEndian.Uint16(cur)
		cur = cur[2:]
	}
	{
		if len(cur) < 2 {
			return nil, errors.New("data too short")
		}
		u.UnionLen = binary.BigEndian.Uint16(cur)
		cur = cur[2:]
	}
	{
		if len(cur) < int(u.UnionLen) {
			return nil, errors.New("data too short")
		}
		restore := cur[int(u.UnionLen):]
		cur = cur[:int(u.UnionLen)]
		switch {
		case u.Tag == 1:
			{
				if len(cur) < 1 {
					return nil, errors.New("data too short")
				}
				u.R = cur[0]
				cur = cur[1:]
			}
			{
				if len(cur) < 1 {
					return nil, errors.New("data too short")
				}
				u.G = cur[0]
				cur = cur[1:]
			}
			{
				if len(cur) < 1 {
					return nil, errors.New("data too short")
				}
				u.B = cur[0]
				cur = cur[1:]
			}
		case u.Tag == 2:
			{
				if len(cur) < 2 {
					return nil, errors.New("data too short")
				}
				u.Year = binary.BigEndian.Uint16(cur)
				cur = cur[2:]
			}
			{
				if len(cur) < 1 {
					return nil, errors.New("data too short")
				}
				u.Month = cur[0]
				cur = cur[1:]
			}
			{
				if len(cur) < 1 {
					return nil, errors.New("data too short")
				}
				u.Day = cur[0]
				cur = cur[1:]
			}
			{
				cur = []byte{}
			}
		default:
			{
				u.Unparseable = make([]uint8, 0)
				for len(cur) > 0 {
					var tmp uint8
					if len(cur) < 1 {
						return nil, errors.New("data too short")
					}
					tmp = cur[0]
					cur = cur[1:]
					u.Unparseable = append(u.Unparseable, tmp)
				}
			}
		}
		if len(cur) > 0 {
			return nil, errors.New("trailing data disallowed")
		}
		cur = restore
	}
	{
		if len(cur) < 2 {
			return nil, errors.New("data too short")
		}
		u.RightAfterTheUnion = binary.BigEndian.Uint16(cur)
		cur = cur[2:]
	}
	return cur, nil
}

func ParseUnionWithLen(data []byte) (*UnionWithLen, error) {
	u := new(UnionWithLen)
	_, err := u.Parse(data)
	if err != nil {
		return nil, err
	}
	return u, nil
}
