// Code generated by trunnel. DO NOT EDIT.

package unionbasic

import (
	"bytes"
	"encoding/binary"
	"errors"
)

const TDate = 2

const TInteger = 3

const TIntarray = 4

const TVararray = 5

const TString = 6

type Date struct {
	Year  uint16
	Month uint8
	Day   uint8
}

func (d *Date) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 2 {
			return nil, errors.New("data too short")
		}
		d.Year = binary.BigEndian.Uint16(cur)
		cur = cur[2:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		d.Month = cur[0]
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		d.Day = cur[0]
		cur = cur[1:]
	}
	return cur, nil
}

type Basic struct {
	Tag        uint8
	D          *Date
	Num        uint32
	Eightbytes [8]uint8
	String     string
}

func (b *Basic) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		b.Tag = cur[0]
		if !(b.Tag == TDate || b.Tag == TInteger || b.Tag == TIntarray || b.Tag == TVararray || b.Tag == TString) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		switch {
		case b.Tag == TDate:
			{
				var err error
				b.D = new(Date)
				cur, err = b.D.Parse(cur)
				if err != nil {
					return nil, err
				}
			}
		case b.Tag == TInteger:
			{
				if len(cur) < 4 {
					return nil, errors.New("data too short")
				}
				b.Num = binary.BigEndian.Uint32(cur)
				cur = cur[4:]
			}
		case b.Tag == TIntarray:
			{
				for i := 0; i < 8; i++ {
					if len(cur) < 1 {
						return nil, errors.New("data too short")
					}
					b.Eightbytes[i] = cur[0]
					cur = cur[1:]
				}
			}
		case b.Tag == TString:
			{
				i := bytes.IndexByte(cur, 0)
				if i < 0 {
					return nil, errors.New("could not parse nul-term string")
				}
				b.String, cur = string(cur[:i]), cur[i+1:]
			}
		}
	}
	return cur, nil
}
