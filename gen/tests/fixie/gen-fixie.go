// Code generated by trunnel. DO NOT EDIT.

package fixie

import (
	"encoding/binary"
	"errors"
)

type Color struct {
	R uint8
	G uint8
	B uint8
}

func (c *Color) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		c.R = cur[0]
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		c.G = cur[0]
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		c.B = cur[0]
		cur = cur[1:]
	}
	return cur, nil
}

func ParseColor(data []byte) (*Color, error) {
	c := new(Color)
	_, err := c.Parse(data)
	if err != nil {
		return nil, err
	}
	return c, nil
}

type FixieDemo struct {
	Bytes      [8]uint8
	Letters    [8]byte
	Shortwords [4]uint16
	Words      [2]uint32
	BigWords   [2]uint64
	Colors     [2]*Color
}

func (f *FixieDemo) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		for idx := 0; idx < 8; idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			f.Bytes[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		for idx := 0; idx < 8; idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			f.Letters[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		for idx := 0; idx < 4; idx++ {
			if len(cur) < 2 {
				return nil, errors.New("data too short")
			}
			f.Shortwords[idx] = binary.BigEndian.Uint16(cur)
			cur = cur[2:]
		}
	}
	{
		for idx := 0; idx < 2; idx++ {
			if len(cur) < 4 {
				return nil, errors.New("data too short")
			}
			f.Words[idx] = binary.BigEndian.Uint32(cur)
			cur = cur[4:]
		}
	}
	{
		for idx := 0; idx < 2; idx++ {
			if len(cur) < 8 {
				return nil, errors.New("data too short")
			}
			f.BigWords[idx] = binary.BigEndian.Uint64(cur)
			cur = cur[8:]
		}
	}
	{
		for idx := 0; idx < 2; idx++ {
			var err error
			f.Colors[idx] = new(Color)
			cur, err = f.Colors[idx].Parse(cur)
			if err != nil {
				return nil, err
			}
		}
	}
	return cur, nil
}

func ParseFixieDemo(data []byte) (*FixieDemo, error) {
	f := new(FixieDemo)
	_, err := f.Parse(data)
	if err != nil {
		return nil, err
	}
	return f, nil
}
