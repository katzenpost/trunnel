// Code generated by trunnel. DO NOT EDIT.

package fixie

import (
	"encoding/binary"
	"errors"
)

const NumBytes = 8

type Color struct {
	R uint8
	G uint8
	B uint8
}

func (c *Color) Parse(data []byte) ([]byte, error) {
	{
		if len(data) < 1 {
			return nil, errors.New("data too short")
		}
		c.R = data[0]
		data = data[1:]
	}
	{
		if len(data) < 1 {
			return nil, errors.New("data too short")
		}
		c.G = data[0]
		data = data[1:]
	}
	{
		if len(data) < 1 {
			return nil, errors.New("data too short")
		}
		c.B = data[0]
		data = data[1:]
	}
	return data, nil
}

type FixieDemo struct {
	Bytes      [NumBytes]uint8
	Letters    [8]byte
	Shortwords [4]uint16
	Words      [2]uint32
	BigWords   [2]uint64
	Colors     [2]*Color
}

func (f *FixieDemo) Parse(data []byte) ([]byte, error) {
	{
		for i := 0; i < NumBytes; i++ {
			if len(data) < 1 {
				return nil, errors.New("data too short")
			}
			f.Bytes[i] = data[0]
			data = data[1:]
		}
	}
	{
		for i := 0; i < 8; i++ {
			if len(data) < 1 {
				return nil, errors.New("data too short")
			}
			f.Letters[i] = data[0]
			data = data[1:]
		}
	}
	{
		for i := 0; i < 4; i++ {
			if len(data) < 2 {
				return nil, errors.New("data too short")
			}
			f.Shortwords[i] = binary.BigEndian.Uint16(data)
			data = data[2:]
		}
	}
	{
		for i := 0; i < 2; i++ {
			if len(data) < 4 {
				return nil, errors.New("data too short")
			}
			f.Words[i] = binary.BigEndian.Uint32(data)
			data = data[4:]
		}
	}
	{
		for i := 0; i < 2; i++ {
			if len(data) < 8 {
				return nil, errors.New("data too short")
			}
			f.BigWords[i] = binary.BigEndian.Uint64(data)
			data = data[8:]
		}
	}
	{
		for i := 0; i < 2; i++ {
			var err error
			f.Colors[i] = new(Color)
			data, err = f.Colors[i].Parse(data)
			if err != nil {
				return nil, err
			}
		}
	}
	return data, nil
}
