// Code generated by trunnel. DO NOT EDIT.

package fixie

import (
	"encoding/binary"
	"errors"
)

const NumBytes = 8

type Color struct {
	R uint8
	G uint8
	B uint8
}

func (c *Color) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		c.R = cur[0]
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		c.G = cur[0]
		cur = cur[1:]
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		c.B = cur[0]
		cur = cur[1:]
	}
	return cur, nil
}

type FixieDemo struct {
	Bytes      [NumBytes]uint8
	Letters    [8]byte
	Shortwords [4]uint16
	Words      [2]uint32
	BigWords   [2]uint64
	Colors     [2]*Color
}

func (f *FixieDemo) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		for i := 0; i < NumBytes; i++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			f.Bytes[i] = cur[0]
			cur = cur[1:]
		}
	}
	{
		for i := 0; i < 8; i++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			f.Letters[i] = cur[0]
			cur = cur[1:]
		}
	}
	{
		for i := 0; i < 4; i++ {
			if len(cur) < 2 {
				return nil, errors.New("data too short")
			}
			f.Shortwords[i] = binary.BigEndian.Uint16(cur)
			cur = cur[2:]
		}
	}
	{
		for i := 0; i < 2; i++ {
			if len(cur) < 4 {
				return nil, errors.New("data too short")
			}
			f.Words[i] = binary.BigEndian.Uint32(cur)
			cur = cur[4:]
		}
	}
	{
		for i := 0; i < 2; i++ {
			if len(cur) < 8 {
				return nil, errors.New("data too short")
			}
			f.BigWords[i] = binary.BigEndian.Uint64(cur)
			cur = cur[8:]
		}
	}
	{
		for i := 0; i < 2; i++ {
			var err error
			f.Colors[i] = new(Color)
			cur, err = f.Colors[i].Parse(cur)
			if err != nil {
				return nil, err
			}
		}
	}
	return cur, nil
}
