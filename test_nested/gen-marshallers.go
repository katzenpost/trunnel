// Code generated by trunnel. DO NOT EDIT.

package nested

import (
	"encoding/binary"
	"errors"
)

type Inner struct {
	Value  uint8
	Number uint16
}

func (i *Inner) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		i.Value = cur[0]
		cur = cur[1:]
	}
	{
		if len(cur) < 2 {
			return nil, errors.New("data too short")
		}
		i.Number = binary.BigEndian.Uint16(cur)
		cur = cur[2:]
	}
	return cur, nil
}

func ParseInner(data []byte) (*Inner, error) {
	i := new(Inner)
	_, err := i.Parse(data)
	if err != nil {
		return nil, err
	}
	return i, nil
}

func (i *Inner) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(i.Value))
	{
		tmp := make([]byte, 2)
		binary.BigEndian.PutUint16(tmp, i.Number)
		buf = append(buf, tmp...)
	}
	return buf
}

func (i *Inner) MarshalBinary() ([]byte, error) {
	if err := i.validate(); err != nil {
		return nil, err
	}
	return i.encodeBinary(), nil
}

func (i *Inner) validate() error {
	return nil
}

type Outer struct {
	Tag   uint8
	Data  *Inner
	Count uint8
	Items []*Inner
}

func (o *Outer) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		o.Tag = cur[0]
		cur = cur[1:]
	}
	{
		var err error
		o.Data = new(Inner)
		cur, err = o.Data.Parse(cur)
		if err != nil {
			return nil, err
		}
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		o.Count = cur[0]
		cur = cur[1:]
	}
	{
		o.Items = make([]*Inner, int(o.Count))
		for idx := 0; idx < int(o.Count); idx++ {
			var err error
			o.Items[idx] = new(Inner)
			cur, err = o.Items[idx].Parse(cur)
			if err != nil {
				return nil, err
			}
		}
	}
	return cur, nil
}

func ParseOuter(data []byte) (*Outer, error) {
	o := new(Outer)
	_, err := o.Parse(data)
	if err != nil {
		return nil, err
	}
	return o, nil
}

func (o *Outer) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(o.Tag))
	buf = append(buf, o.Data.encodeBinary()...)
	buf = append(buf, byte(o.Count))
	for idx := 0; idx < int(o.Count); idx++ {
		buf = append(buf, o.Items[idx].encodeBinary()...)
	}
	return buf
}

func (o *Outer) MarshalBinary() ([]byte, error) {
	if err := o.validate(); err != nil {
		return nil, err
	}
	return o.encodeBinary(), nil
}

func (o *Outer) validate() error {
	if o.Data != nil {
		if err := o.Data.validate(); err != nil {
			return err
		}
	}
	if len(o.Items) != int(o.Count) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(o.Items); idx++ {
		if o.Items[idx] != nil {
			if err := o.Items[idx].validate(); err != nil {
				return err
			}
		}
	}
	return nil
}
