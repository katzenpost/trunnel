{

package parser

}

//  Declarations ::= Declaration
//  Declarations ::= Declarations Declaration
//  File ::= Declarations

File <- ds:Declaration* EOF {
  f := &ast.File{}
  for _, i := range ds.([]interface{}) {
    switch d := i.(type) {
      case *ast.Constant:
        f.Constants = append(f.Constants, d)
      case *ast.Struct:
        f.Structs = append(f.Structs, d)
      default:
        return nil, errors.New("unknown declaration")
    }
  }
  return f, nil
}

//  Declaration ::= OptAnnotation ConstDecl
//  Declaration ::= OptAnnotation ContextDecl OptSemi
//  Declaration ::= OptAnnotation StructDecl OptSemi
//  Declaration ::= extern struct ID OptWithContext ;
//  Declaration ::= trunnel ID IDList ;

Declaration <- d:(ConstDecl / StructDecl) _ {
  return d, nil
}

//  ConstDecl ::= const CONST_ID = INT ;

ConstDecl <- "const" __ n:ConstIdentifier _ '=' _ v:IntegerLiteral _ ';' {
  return &ast.Constant{
    Name: n.(string),
    Value: v.(int64),
  }, nil
}

//  StructDecl ::= struct ID OptWithContext { StructMembers StructEnding }

StructDecl <- "struct" __ n:Identifier __ '{' ms:StructMember* e:StructEnding? '}' ';'? {
  fmt.Println("STRUCT")
  return &ast.Struct{}, nil
}

//  OptWithContext ::=
//  OptWithContext ::= with context IDList
//  TODO(mbm): context support

//  StructMembers ::=
//  StructMembers ::= StructMembers OptAnnotation StructMember ;

//  StructMember ::= SMArray
//  StructMember ::= SMInteger
//  StructMember ::= SMString
//  StructMember ::= SMStruct
//  StructMember ::= SMUnion

StructMember <- _ m:SMInteger _ {
  return m, nil
}

//  StructEnding ::=
//  StructEnding ::= SMRemainder ;
//  StructEnding ::= eos ;

StructEnding <- "eos"

//  SMInteger ::= IntType ID OptIntConstraint

SMInteger <- t:IntType _ n:Identifier _ ';' {
  fmt.Println(t, n)
  return nil, nil
}

//  IntType ::= u16
//  IntType ::= u32
//  IntType ::= u64
//  IntType ::= u8

IntType <- 'u' b:("8" / "16" / "32" / "64") {
  s, err := strconv.Atoi(string(b.([]byte)))
  return &ast.IntType{Size: s}, err
}

// Identifiers

Identifier <- [a-zA-Z_] [a-zA-Z0-9_]* {
  return string(c.text), nil
}

ConstIdentifier <- [A-Z_] [A-Z0-9_]* {
  return string(c.text), nil
}

// Primitives

IntegerLiteral <- (DecimalLiteral / HexLiteral / OctalLiteral) {
  return strconv.ParseInt(string(c.text), 0, 64)
}

DecimalLiteral <- [1-9]+ [0-9]*

HexLiteral <- "0x" [0-9a-fA-F]+

OctalLiteral <- '0' [0-7]+

// Character classes

_ "optional whitespace" <- [ \t\n]*
__ "whitespace" <- [ \t\n]+

EOL <- '\n'
EOF <- !.

//
//
//  SMArray ::= SMFixedArray
//  SMArray ::= SMVarArray
//  SMString ::= nulterm ID
//  SMStruct ::= StructDecl ID
//  SMStruct ::= struct ID ID
//  SMUnion ::= union ID [ IDRef ] OptUnionLength { UnionMembers }
//
//  ArrayBase ::= IntType
//  ArrayBase ::= StructDecl
//  ArrayBase ::= char
//  ArrayBase ::= struct ID
//  ContextDecl ::= context ID { ContextMembers }
//  ContextMember ::= IntType ID ;
//  ContextMembers ::=
//  ContextMembers ::= ContextMembers OptAnnotation ContextMember
//  IDList ::= ID
//  IDList ::= IDList , ID
//  IDRef ::= ID
//  IDRef ::= ID . ID
//  IntList ::= IntList , IntListMember
//  IntList ::= IntListMember
//  IntListMember ::= Integer
//  IntListMember ::= Integer .. Integer
//  Integer ::= CONST_ID
//  Integer ::= INT
//  LengthKW ::= ID
//  OptAnnotation ::=
//  OptAnnotation ::= ANNOTATION
//  OptExtentSpec ::=
//  OptExtentSpec ::= ... ;
//  OptExtentSpec ::= SMRemainder ;
//  OptIntConstraint ::=
//  OptIntConstraint ::= IN [ IntList ]
//  OptSemi ::=
//  OptSemi ::= ;
//  OptUnionLength ::=
//  OptUnionLength ::= with LengthKW .. - Integer
//  OptUnionLength ::= with LengthKW IDRef
//  SMFixedArray ::= ArrayBase ID [ Integer ]
//  SMRemainder ::= OptAnnotation ArrayBase ID [ ]
//  SMVarArray ::= ArrayBase ID [ .. - Integer ]
//  SMVarArray ::= ArrayBase ID [ IDRef ]
//  UnionCase ::= IntList
//  UnionCase ::= default
//  UnionField ::= SMFixedArray
//  UnionField ::= SMInteger
//  UnionField ::= SMString
//  UnionField ::= SMStruct
//  UnionField ::= SMVarArray
//  UnionFields ::= ;
//  UnionFields ::= SMRemainder ;
//  UnionFields ::= UnionField ;
//  UnionFields ::= UnionFields UnionField ;
//  UnionFields ::= fail ;
//  UnionFields ::= ignore ;
//  UnionMember ::= UnionCase : UnionFields OptExtentSpec
//  UnionMembers ::= UnionMember
//  UnionMembers ::= UnionMembers UnionMember
//
//
// Additional constraints:
//
//    Structure declarations form a DAG.
//
//    Field references in SMVarArray and SMUnion and SMUnionLength refer
//    only to earlier-occurring fields in the same structure.
//
//    No ExtentSpec unless the union has a UnionLength.
