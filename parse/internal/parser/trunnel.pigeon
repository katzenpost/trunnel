{

package parser

const lingeringDeclarationsKey = "lingering_declarations"

func (c *current) addLingeringDeclaration(d interface{}) {
  var ds []interface{}
  if e, ok := c.state[lingeringDeclarationsKey]; ok {
    ds = e.([]interface{})
  }
  c.state[lingeringDeclarationsKey] = append(ds, d)
}

func (c *current) getLingeringDeclarations() []interface{} {
  if ds, ok := c.state[lingeringDeclarationsKey]; ok {
    return ds.([]interface{})
  }
  return []interface{}{}
}

}

//  Declarations ::= Declaration
//  Declarations ::= Declarations Declaration
//  File ::= Declarations

File <- ds:Declaration* EOF {
  f := &ast.File{}
  lingering := c.getLingeringDeclarations()
  decls := append(ds.([]interface{}), lingering...)
  for _, i := range decls {
    switch d := i.(type) {
      case *ast.Constant:
        f.Constants = append(f.Constants, d)
      case *ast.Struct:
        f.Structs = append(f.Structs, d)
      case *ast.Pragma:
        f.Pragmas = append(f.Pragmas, d)
      default:
        return nil, errors.New("unknown declaration")
    }
  }
  return f, nil
}

//  Declaration ::= OptAnnotation ConstDecl
//  Declaration ::= OptAnnotation ContextDecl OptSemi XXX
//  Declaration ::= OptAnnotation StructDecl OptSemi
//  Declaration ::= extern struct ID OptWithContext ; XXX
//  Declaration ::= trunnel ID IDList ;

Declaration <- _ d:(ConstDeclaration / StructDeclaration / PragmaDeclaration) _ {
  return d, nil
}

//  ConstDecl ::= const CONST_ID = INT ;

ConstDeclaration <- "const" __ n:ConstIdentifier _ '=' _ v:IntLiteral _ ';' {
  return &ast.Constant{
    Name: n.(string),
    Value: v.(int64),
  }, nil
}

// StructDeclaration is a top-level struct declaration, which may be followed
// by a semi-colon.

StructDeclaration <- s:StructDecl _ ';'? {
  return s, nil
}

//  StructDecl ::= struct ID OptWithContext { StructMembers StructEnding }

StructDecl <- n:StructIdentifier __ '{' ms:StructMember* e:StructEnding? '}' {
  m := make([]ast.StructMember, 0)
  for _, i := range ms.([]interface{}) {
    m = append(m, i.(ast.StructMember))
  }
  return &ast.Struct{
    Name: n.(string),
    Members: m,
  }, nil
}

StructIdentifier <- "struct" __ n:Identifier {
  return n, nil
}

PragmaDeclaration <- "trunnel" __ n:Identifier __ opts:IdentifierList _ ';' {
  return &ast.Pragma{
    Type: n.(string),
    Options: opts.([]string),
  }, nil
}

//  OptWithContext ::=
//  OptWithContext ::= with context IDList XXX

//  StructMembers ::=
//  StructMembers ::= StructMembers OptAnnotation StructMember ; XXX

//  StructMember ::= SMArray
//  StructMember ::= SMInteger
//  StructMember ::= SMString XXX
//  StructMember ::= SMStruct XXX
//  StructMember ::= SMUnion XXX

StructMember <- _ m:(SMArray / SMInteger) _ {
  return m, nil
}

//  StructEnding ::=
//  StructEnding ::= SMRemainder ;
//  StructEnding ::= eos ;

StructEnding <- "eos"

//  SMArray ::= SMFixedArray
//  SMArray ::= SMVarArray XXX

SMArray <- a:SMFixedArray _ ';' {
  return a, nil
}

//  SMFixedArray ::= ArrayBase ID [ Integer ]

SMFixedArray <- b:ArrayBase __ n:Identifier _ '[' s:Integer ']' {
  return &ast.FixedArrayMember{
    Base: b.(ast.ArrayBase),
    Name: n.(string),
    Size: s.(ast.Integer),
  }, nil
}

//  ArrayBase ::= IntType
//  ArrayBase ::= StructDecl XXX
//  ArrayBase ::= char
//  ArrayBase ::= struct ID

ArrayBase <- t:(IntType / CharType / StructRef) {
  return t, nil
}


//  SMInteger ::= IntType ID OptIntConstraint

SMInteger <- t:IntType _ n:Identifier _ cst:IntConstraint? _ ';' {
  m := &ast.IntegerMember{
    Type: t.(*ast.IntType),
    Name: n.(string),
  }
  if cst != nil {
    m.Constraint = cst.(*ast.IntegerList)
  }
  return m, nil
}

StructRef <- s:StructDecl {
  c.addLingeringDeclaration(s)
  return &ast.StructRef{Name: s.(*ast.Struct).Name}, nil
} / n:StructIdentifier {
  return &ast.StructRef{Name: n.(string)}, nil
}

CharType <- "char" {
  return &ast.CharType{}, nil
}

//  IntType ::= u16
//  IntType ::= u32
//  IntType ::= u64
//  IntType ::= u8

IntType <- 'u' b:("8" / "16" / "32" / "64") {
  s, err := strconv.Atoi(string(b.([]byte)))
  return &ast.IntType{Size: s}, err
}

//  OptIntConstraint ::=
//  OptIntConstraint ::= IN [ IntList ]

IntConstraint <- "IN" __ '[' _ l:IntList _ ']' {
  return l, nil
}

//  IntList ::= IntList , IntListMember
//  IntList ::= IntListMember

IntList <- m:IntListMember ms:(_ ',' _ IntListMember)* {
  r := []*ast.IntegerRange{m.(*ast.IntegerRange)}
  for _, i := range ms.([]interface{}) {
    r = append(r, i.([]interface{})[3].(*ast.IntegerRange))
  }
  return &ast.IntegerList{Ranges: r}, nil
}

//  IntListMember ::= Integer
//  IntListMember ::= Integer .. Integer

IntListMember <- lo:Integer hi:( ".." Integer )? {
  r := &ast.IntegerRange{
    Low: lo.(ast.Integer),
  }
  if hi != nil {
    r.High = hi.([]interface{})[1].(ast.Integer)
  }
  return r, nil
}

//  Integer ::= CONST_ID
//  Integer ::= INT

Integer <- i:(IntegerConstRef / IntegerLiteral) {
  return i, nil
}

IntegerConstRef <- n:ConstIdentifier {
  return &ast.IntegerConstRef{Name: n.(string)}, nil
}

IntegerLiteral <- v:IntLiteral {
  return &ast.IntegerLiteral{Value: v.(int64)}, nil
}

// Identifiers

IdentifierList <- n:Identifier ns:(_ ',' _ Identifier)* {
  ids := []string{n.(string)}
  for _, i := range ns.([]interface{}) {
    ids = append(ids, i.([]interface{})[3].(string))
  }
  return ids, nil
}

Identifier <- [a-zA-Z_] [a-zA-Z0-9_]* {
  return string(c.text), nil
}

ConstIdentifier <- [A-Z_] [A-Z0-9_]* {
  return string(c.text), nil
}

// Primitives

IntLiteral <- (HexLiteral / OctalLiteral / DecimalLiteral) {
  return strconv.ParseInt(string(c.text), 0, 64)
}

DecimalLiteral <- [0-9]+ [0-9]*

HexLiteral <- "0x" [0-9a-fA-F]+

OctalLiteral <- '0' [0-7]+

// Character classes

_ "optional whitespace" <- [ \t\n]*
__ "whitespace" <- [ \t\n]+

EOL <- '\n'
EOF <- !.

//
//
//  SMString ::= nulterm ID
//  SMStruct ::= StructDecl ID
//  SMStruct ::= struct ID ID
//  SMUnion ::= union ID [ IDRef ] OptUnionLength { UnionMembers }
//
//  ContextDecl ::= context ID { ContextMembers }
//  ContextMember ::= IntType ID ;
//  ContextMembers ::=
//  ContextMembers ::= ContextMembers OptAnnotation ContextMember
//  IDList ::= ID
//  IDList ::= IDList , ID
//  IDRef ::= ID
//  IDRef ::= ID . ID
//  LengthKW ::= ID
//  OptAnnotation ::=
//  OptAnnotation ::= ANNOTATION
//  OptExtentSpec ::=
//  OptExtentSpec ::= ... ;
//  OptExtentSpec ::= SMRemainder ;
//  OptSemi ::=
//  OptSemi ::= ;
//  OptUnionLength ::=
//  OptUnionLength ::= with LengthKW .. - Integer
//  OptUnionLength ::= with LengthKW IDRef
//  SMRemainder ::= OptAnnotation ArrayBase ID [ ]
//  SMVarArray ::= ArrayBase ID [ .. - Integer ]
//  SMVarArray ::= ArrayBase ID [ IDRef ]
//  UnionCase ::= IntList
//  UnionCase ::= default
//  UnionField ::= SMFixedArray
//  UnionField ::= SMInteger
//  UnionField ::= SMString
//  UnionField ::= SMStruct
//  UnionField ::= SMVarArray
//  UnionFields ::= ;
//  UnionFields ::= SMRemainder ;
//  UnionFields ::= UnionField ;
//  UnionFields ::= UnionFields UnionField ;
//  UnionFields ::= fail ;
//  UnionFields ::= ignore ;
//  UnionMember ::= UnionCase : UnionFields OptExtentSpec
//  UnionMembers ::= UnionMember
//  UnionMembers ::= UnionMembers UnionMember
//
//
// Additional constraints:
//
//    Structure declarations form a DAG.
//
//    Field references in SMVarArray and SMUnion and SMUnionLength refer
//    only to earlier-occurring fields in the same structure.
//
//    No ExtentSpec unless the union has a UnionLength.
